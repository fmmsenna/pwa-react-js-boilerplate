/* eslint-disable no-restricted-globals */

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate, NetworkFirst } from "workbox-strategies";
import { getFullVersion } from "./version";

clientsClaim();

const cacheName = `PWA-Template-${getFullVersion()}`;

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// ... (keep existing route registrations)

self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  } else if (event.data && event.data.type === "CHECK_FOR_UPDATES") {
    self.registration.update().then(() => {
      if (self.registration.waiting) {
        // New content is available, notify all clients
        self.clients.matchAll().then((clients) => {
          clients.forEach((client) =>
            client.postMessage({ type: "UPDATE_AVAILABLE" })
          );
        });
      }
    });
  }
});

self.addEventListener("install", (event) => {
  self.skipWaiting();
  event.waitUntil(
    caches.open(cacheName).then((cache) => {
      return cache.addAll([
        // ... (keep your existing cache list)
      ]);
    })
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(self.clients.claim());
  // Clear old caches
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((name) => {
          if (name !== cacheName) {
            return caches.delete(name);
          }
        })
      );
    })
  );
});

// Check for updates every minute (you can adjust this interval)
setInterval(() => {
  self.registration.update();
}, 60000);
